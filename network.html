<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* ... (Styles remain unchanged) ... */
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 50px;
            background: linear-gradient(270deg, #4b0082, #7a1fa2, #8a2be2);
            background-size: 600% 600%;
            animation: gradientMove 15s ease infinite;
            color: white;
            font-family: 'Cairo', sans-serif;
            overflow-x: hidden;
            direction: rtl;
        }
        @keyframes gradientMove {
            0% {background-position: 0% 50;}
            50% {background-position: 100% 50;}
            100% {background-position: 0% 50;}
        }
        .container {
            position: relative;
            z-index: 1;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 0 0 25px rgba(0,0,0,0.5);
            text-align: center;
            width: 95%;
            max-width: 1400px;
            margin-bottom: 50px;
            animation: fadeIn 1s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        h1 {
            margin-bottom: 25px;
            font-size: 2.5em;
            color: #fff;
        }
        #metrics {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 1.2em;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
        }
        #metrics span {
            font-weight: bold;
            color: #00ffcc;
        }
        #chartWrapper {
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 15px;
            overflow-x: auto;
            max-width: 100%; 
            box-sizing: border-box;
        }
        #networkChart {
            min-width: 100%; 
            width: 100%;
            height: 200px !important;
            max-height: 200px !important;
        }
        #alertsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 30px;
            font-size: 0.9em;
        }
        #alertsTable thead tr {
            background: #8a2be2;
            border-bottom: 2px solid #9b30ff;
        }
        #alertsTable th, #alertsTable td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        #alertsTable tbody tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .status-up { color: #00ffcc; font-weight: bold; }
        .status-down { color: #ff8080; font-weight: bold; }
        .status-blocked { background-color: #ff8080; color: #fff; padding: 3px 8px; border-radius: 5px; }
        .severity-low { color: #ff4081; }
        .severity-medium { color: #ffeb3b; }
        .severity-high { color: #00ffcc; }
        .score-good { 
            color: #00ffcc;
            font-weight: bold;
        }
        .score-bad { 
            color: #ff4081;
            font-weight: bold;
        }
        .score-neutral { 
            color: #ffeb3b;
            font-weight: bold;
        }
        .mac-recommended { color: #00ffcc; font-weight: bold; }
        .mac-unknown { color: #ff4081; font-weight: bold; }
        .action-btn {
            background: #8a2be2;
            border: none;
            padding: 6px 12px;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.3s;
            font-size: 0.9em;
            margin: 2px;
        }
        .action-btn:hover {
            background: #9b30ff;
            transform: scale(1.05);
        }
        .allow-btn { background-color: #007bff; }
        .allow-btn:hover { background-color: #0056b3; }
        .block-btn { background-color: #dc3545; }
        .block-btn:hover { background-color: #bd2130; }
        .inline-popup { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª</h1>
        <div id="metrics">
            <p>Ø¹Ø¯Ø¯ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª: <span id="m_flows">0</span></p>
            <p>Ø§Ø³Ù… Ø§Ù„Ø¬Ù‡Ø§Ø²: <span id="m_hostname">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„</span></p>
            <p>Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù„Ø§Ø³Ù„ÙƒÙŠØ© (SSID): <span id="m_ssid">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„</span></p>
        </div>
        <div class="action-buttons-group">
            <button id="exportCsvBtn" onclick="showSaveDurationPopup('csv')">ğŸ“Š Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙˆÙ„ CSV</button>
            <button id="exportChartPngBtn" onclick="showSaveDurationPopup('png')">ğŸ–¼ï¸ Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ PNG</button>
        </div>
        <div id="chartWrapper">
            <canvas id="networkChart" height="200"></canvas>
        </div>
        <table id="alertsTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Network</th>
                    <th>IPv4</th>
                    <th>IPv6</th>
                    <th>Ø§Ù„ØªÙˆØµÙŠØ§Øª</th>
                    <th>Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„</th>
                    <th>Ø¯Ø±Ø¬Ø© Ø§Ù„Ø£Ù…Ø§Ù†</th>
                    <th>Ø§Ù„Ø­Ø§Ù„Ø©</th>
                    <th>Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="inlinePopup" class="inline-popup" tabindex="-1" aria-hidden="true"></div> 
    <div id="interfaceListPopup" style="display: none;"></div>
    
    <script>
        let dataFetcherInterval; 
        
        // ** (Mock Data & Client-Side Functions) **
        let mockBlockedInterfaces = {};
        
        function generateMockNetworkData() {
            const interfaces = [
                { name: 'Ethernet0', is_up: true, protocol: "TCP/UDP (Ethernet)", ipv4: '192.168.1.10', ipv6: 'fe80::1:2345:6789:abcd', mac: '00:1A:2B:3C:4D:5E' },
                { name: 'Wi-Fi', is_up: true, protocol: "TCP/UDP (Wireless)", ipv4: '192.168.1.11', ipv6: 'fe80::2:1234:5678:90ab', mac: 'FF:EE:DD:CC:BB:AA' },
                { name: 'Loopback', is_up: true, protocol: "Loopback (TCP/IP)", ipv4: '127.0.0.1', ipv6: '::1', mac: '-' },
                { name: 'VMnet1', is_up: false, protocol: "TCP/UDP (Virtual)", ipv4: '10.0.0.1', ipv6: 'fe80::3:9876:5432:fedc', mac: 'AB:CD:EF:12:34:56' },
            ];

            const now = Date.now();
            
            return {
                network: {
                    hostname: 'DESKTOP-MOCK-ML',
                    ssid: 'MOCK_WIFI_NETWORK',
                    interfaces: interfaces.map(iface => {
                        const isBlocked = mockBlockedInterfaces[iface.name] === null || 
                                          (mockBlockedInterfaces[iface.name] && mockBlockedInterfaces[iface.name] > now);

                        let ml_score = (Math.random() * 1.0).toFixed(2);
                        let severity;
                        let mac_status = "Unknown";
                        
                        if (!iface.is_up || isBlocked) {
                            severity = "Low";
                            ml_score = "0.00"; 
                        } else if (parseFloat(ml_score) >= 0.7) {
                            severity = "High";
                            mac_status = "Recommended";
                        } else if (parseFloat(ml_score) >= 0.3) {
                            severity = "Medium";
                        } else {
                            severity = "Low";
                        }
                        
                        let score_value = parseFloat(ml_score); 
                        
                        return {
                            ...iface,
                            ml_score: score_value,
                            severity: severity,
                            mac_status: mac_status,
                            is_blocked: isBlocked
                        };
                    })
                }
            };
        }

        async function getJSON(url) {
            // ÙŠØ³ØªØ®Ø¯Ù… Mock Data
            return generateMockNetworkData();
        }

        async function postJSON(url, data) {
            // ÙŠØ­Ø§ÙƒÙŠ Ø¹Ù…Ù„ Ø§Ù„Ø­Ø¸Ø±
            const parts = url.split('/');
            const action = parts[2]; 
            const interfaceName = parts[3];

            if (action.startsWith('block')) {
                mockBlockedInterfaces[interfaceName] = null; 
                return { status: "blocked", interface: interfaceName };
            } 
            
            if (action === 'allow') {
                delete mockBlockedInterfaces[interfaceName];
                return { status: "allowed", interface: interfaceName };
            }
            
            return { status: "error" };
        }
        // ** (Ù†Ù‡Ø§ÙŠØ© Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª) **

        const MAX_INCREMENT_FACTOR = 0.10;
        const INCREMENT_TIME = 2000;
        const FETCH_TIME = 2000; 
        let interfaceSpeeds = {}; 
        let lastActiveCount = null;
        let lastActiveInterfaces = new Set();
        
        let historyData = []; 
        let maxDisplaySeconds = 300; 
        let interfaceToBlock = null;
        let selectedDuration = null;
        let popupMode = 'block';
        let currentSsid = 'Unknown_SSID';
        
        // ** Ø¯ÙˆØ§Ù„ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø­Ø§ÙƒÙ‰ **
        function showBlockPopup(interfaceName) {
            // Ø­Ø¸Ø± Ù…Ø¨Ø§Ø´Ø± Ø¨Ø¯ÙˆÙ† popup
            toggleBlock(interfaceName, true);
        }
        
        async function toggleBlock(interfaceName, block) {
            const url = block ? `/api/block/${interfaceName}/permanent` : `/api/allow/${interfaceName}`;
            
            const result = await postJSON(url, {});
            if (result.status !== "error") {
                refreshData(); // ØªØ­Ø¯ÙŠØ« ÙÙˆØ±ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
            } else {
                alert("Ù…Ø­Ø§ÙƒØ§Ø©: ÙØ´Ù„ Ù…Ø­Ø§ÙƒØ§Ø© Ø£Ù…Ø± Ø§Ù„Ø­Ø¸Ø±/Ø§Ù„Ø¥Ù„ØºØ§Ø¡.");
            }
        }
        
        // ** Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±) **
        function getFormattedTime() {
            const now = new Date();
            const date = now.toLocaleDateString('en-CA').replace(/-/g, '_');
            const time = now.toLocaleTimeString('en-US', { hour12: false }).replace(/:/g, '_');
            return `${date}_${time}`;
        }
        function toDatetimeLocal(date) {
            const y = date.getFullYear().toString();
            const m = (date.getMonth() + 1).toString().padStart(2, '0');
            const d = date.getDate().toString().padStart(2, '0');
            const h = date.getHours().toString().padStart(2, '0');
            const min = date.getMinutes().toString().padStart(2, '0');
            const s = date.getSeconds().toString().padStart(2, '0');
            return `${y}-${m}-${d}T${h}:${min}:${s}`;
        }
        function getTimeFromDatetimeLocal(datetimeLocalValue) {
            if (!datetimeLocalValue) return NaN;
            const localDate = new Date(datetimeLocalValue);
            if (isNaN(localDate.getTime())) {
                const [datePart, timePart] = datetimeLocalValue.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hours, minutes, seconds] = timePart.split(':').map(Number);
                const fallbackDate = new Date(year, month - 1, day, hours, minutes, seconds || 0); 
                return fallbackDate.getTime();
            }
            return localDate.getTime();
        }
        function getHumanReadableTime(date) {
            if (!date || isNaN(date.getTime())) return 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
            const h = date.getHours().toString().padStart(2, '0');
            const m = date.getMinutes().toString().padStart(2, '0');
            const s = date.getSeconds().toString().padStart(2, '0');
            const d = date.getDate().toString().padStart(2, '0');
            const mo = (date.getMonth() + 1).toString().padStart(2, '0');
            return `${h}:${m}:${s} - ${d}/${mo}`;
        }
        function getDurationString(totalSeconds) {
            if (totalSeconds === 0) return "Realtime";
            const d = Math.floor(totalSeconds / 86400);
            const h = Math.floor((totalSeconds % 86400) / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60); 
            let parts = [];
            if (d > 0) parts.push(`${d} ÙŠÙˆÙ…`);
            if (h > 0) parts.push(`${h} Ø³Ø§Ø¹Ø©`);
            if (m > 0) parts.push(`${m} Ø¯Ù‚ÙŠÙ‚Ø©`);
            if (s > 0 || parts.length === 0) parts.push(`${s} Ø«Ø§Ù†ÙŠØ©`);
            return parts.join(' Ùˆ ');
        }
        function getDurationStringForFileName(totalSeconds) {
            if (totalSeconds === 0) return "Realtime";
            const d = Math.floor(totalSeconds / 86400);
            const h = Math.floor((totalSeconds % 86400) / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60);
            let parts = [];
            if (d > 0) parts.push(`${d}D`);
            if (h > 0) parts.push(`${h}H`);
            if (m > 0) parts.push(`${m}M`);
            if (s > 0 || parts.length === 0) parts.push(`${s}S`);
            return parts.join('_');
        }
        function calculateTotalSecondsFromInputs(prefix) { /* Simplified */ }
        function closePopup() { /* Simplified */ }
        function getMaxAvailableDuration() { /* Simplified */ }
        function selectDuration(duration) { /* Simplified */ }
        function applyBlock() { /* Simplified */ }
        function updateSaveStatus() { /* Simplified */ }
        function showSaveDurationPopup(mode) { /* Simplified */ }
        function handlePopupSave() { /* Simplified */ }
        function saveFileByTimeRange(startTimestamp, endTimestamp) { /* Simplified */ }
        function exportTableToCSV(filteredData, filenameBase, startTimeDate, endTimeDate) { /* Simplified */ }
        function saveChartToPNG(filteredData, filenameBase) { /* Simplified */ }
        function showInterfacesForPoint(event, elements) { /* Simplified */ }
        // ** Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© **

        async function refreshData() {
            // ÙŠØ³ØªØ®Ø¯Ù… Mock Data
            const data = await getJSON('/api/network-info');

            try {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„ Metrics
                currentSsid = data.network.ssid && data.network.ssid.trim() !== '' ? data.network.ssid.replace(/\s/g, '_') : 'Default_LAN';
                document.getElementById('m_hostname').textContent = data.network.hostname || 'ØºÙŠØ± Ù…ØªÙˆÙØ±';
                document.getElementById('m_ssid').textContent = data.network.ssid || 'Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø³Ù„ÙƒÙŠØ© (Default_LAN)';
                
                let allInterfacesData = data.network.interfaces; 
                let currentActiveInterfaces = allInterfacesData.filter(item => item.is_up && !item.is_blocked).map(item => item.interface);
                let activeCount = currentActiveInterfaces.length;
                document.getElementById('m_flows').textContent = allInterfacesData.length || 0;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ
                const now = new Date();
                let changeDetails = null;
                const currentActiveSet = new Set(currentActiveInterfaces);
                const addedInterfaces = currentActiveInterfaces.filter(iface => !lastActiveInterfaces.has(iface));
                const removedInterfaces = Array.from(lastActiveInterfaces).filter(iface => !currentActiveSet.has(iface));
                if (addedInterfaces.length === 1 && removedInterfaces.length === 0) {
                    changeDetails = { type: '+', name: addedInterfaces[0] }; 
                } else if (removedInterfaces.length === 1 && addedInterfaces.length === 0) {
                    changeDetails = { type: '-', name: removedInterfaces[0] }; 
                } else if (addedInterfaces.length > 0 || removedInterfaces.length > 0) {
                    changeDetails = { type: '*', name: '' };
                }
                lastActiveInterfaces = currentActiveSet;
                lastActiveCount = activeCount;
                historyData.push({
                    time: now,
                    label: now.toLocaleTimeString(), 
                    value: activeCount,
                    change: changeDetails, 
                    interfaces: allInterfacesData 
                });
                const cutoff = new Date(now - maxDisplaySeconds * 1000);
                if (historyData.length > 100) historyData = historyData.slice(-100);
                if (historyData.length > 0 && historyData[0].time.getTime() < cutoff.getTime()) {
                    const firstIndexToKeep = historyData.findIndex(d => d.time.getTime() >= cutoff.getTime());
                    if (firstIndexToKeep !== -1) {
                        historyData = historyData.slice(firstIndexToKeep);
                    } else {
                        historyData = [];
                    }
                }
                const dataForDisplay = historyData;
                const chartId = 'networkChart';
                const chart = window[chartId];
                if (chart) {
                    const POINT_WIDTH = 25; 
                    const PADDING_WIDTH = 100;
                    const wrapper = document.getElementById('chartWrapper');
                    const minWidth = wrapper ? wrapper.clientWidth : 400;
                    const calculatedWidth = dataForDisplay.length * POINT_WIDTH + PADDING_WIDTH;
                    const newWidth = Math.max(minWidth, calculatedWidth);
                    chart.canvas.style.width = `${newWidth}px`;
                    chart.canvas.width = newWidth;
                    
                    wrapper.scrollLeft = wrapper.scrollWidth; // ØªÙ…Ø±ÙŠØ± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù†Ù‡Ø§ÙŠØ© Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§
                    
                    chart.data.labels = dataForDisplay.map(d => d.label);
                    chart.data.datasets[0].data = dataForDisplay.map(d => d.value);
                    chart.options.scales.y.max = Math.max(activeCount + 1, 5);
                    chart.options.plugins.interfaceChangeAnnotator.changeData = dataForDisplay.map(d => d.change);
                    chart.update('none');
                }
                
                updateTableOnly(allInterfacesData);
            } catch (e) {
                console.error("Error in refreshData:", e);
            }
        }
        
        function updateTableOnly(allInterfacesData) {
            const tbody = document.querySelector('#alertsTable tbody');
            if (!tbody) return;
            const allInterfacesForTable = allInterfacesData; 
            tbody.innerHTML = '';
            allInterfacesForTable.forEach((item, index) => {
                const number = index + 1;
                const isBlocked = item.is_blocked;
                const currentScore = item.ml_score || 0.0; 
                const statusClass = item.is_up ? 'status-up' : 'status-down'; 
                
                const macStatusClass = item.mac_status === 'Recommended' ? 'mac-recommended' : 'mac-unknown';
                
                const statusText = isBlocked ? 'Ù…Ø­Ø¸ÙˆØ±' : (item.is_up ? 'Ù†Ø´Ø·' : 'ØºÙŠØ± Ù†Ø´Ø·');
                const actionButton = isBlocked
                    ? `<button class="action-btn allow-btn" onclick="toggleBlock('${item.interface}', false)">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¸Ø±</button>`
                    : `<button class="action-btn block-btn" onclick="showBlockPopup('${item.interface}')">Ø­Ø¸Ø±</button>`;
                
                let mlScoreHtml = '-';
                const percentage = Math.round(currentScore * 100); 
                let scoreClass = 'score-neutral';
                let icon = '';
                
                if (percentage >= 70) { 
                    scoreClass = 'score-good'; 
                    icon = ' &nbsp; &#10003;'; 
                } 
                else if (percentage < 40) {
                    scoreClass = 'score-bad'; 
                    icon = ' &nbsp; &#9888;'; 
                }
                
                mlScoreHtml = `<span class="${scoreClass}">${percentage}%${icon}</span>`;
                
                const tr = document.createElement('tr');
                if (isBlocked) {
                    tr.style.backgroundColor = 'rgba(255, 128, 128, 0.2)';
                }
                tr.innerHTML = `
                    <td>${number}</td>
                    <td>${item.interface || '-'}</td>
                    <td>${item.ipv4 || '-'}</td>
                    <td>${item.ipv6 || '-'}</td>
                    <td class="${macStatusClass}">${item.mac_status || '-'}</td> 
                    <td>${item.protocol || '-'}</td>
                    <td>${mlScoreHtml}</td> 
                    <td class="${isBlocked ? 'status-blocked' : statusClass}">${statusText}</td>
                    <td>
                        ${actionButton}
                    </td>`;
                tbody.appendChild(tr);
            });
        }
        const interfaceChangeAnnotator = {
            id: 'interfaceChangeAnnotator',
            changeData: [], 
            afterDraw: (chart) => {
                const { ctx, chartArea: { top, bottom, left, right, width, height }, scales: { x, y } } = chart;
                ctx.save();
                const dataSet = chart.getDatasetMeta(0);
                const changeData = chart.options.plugins.interfaceChangeAnnotator.changeData;
                if (dataSet.data.length === 0 || dataSet.data.length !== changeData.length) {
                    ctx.restore();
                    return;
                }
                ctx.font = '10px Cairo';
                ctx.textAlign = 'center';
                dataSet.data.forEach((point, index) => {
                    const change = changeData[index];
                    if (change && change.type && change.name) {
                        let color = '#fff';
                        let text = '';
                        if (change.type === '+') {
                            color = '#00ffcc';
                            text = `+ ${change.name}`;
                        } else if (change.type === '-') {
                            color = '#ff4081';
                            text = `- ${change.name}`;
                        } else if (change.type === '*') {
                            color = '#ffeb3b';
                            text = `* ${change.name}`;
                        }
                        ctx.fillStyle = color;
                        const xPos = point.x;
                        const yPos = point.y - 15; 
                        ctx.fillText(text, xPos, yPos);
                    }
                });
                ctx.restore();
            }
        };
        document.addEventListener('DOMContentLoaded', () => {
            const chartId = 'networkChart';
            const ctx = document.getElementById(chartId)?.getContext('2d');
            
            if (ctx) {
                window[chartId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Active Interfaces (Unblocked)',
                            data: [],
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 5,
                            pointHoverRadius: 7 
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        onClick: showInterfacesForPoint,
                        scales: {
                            x: {
                                title: { display: true, text: 'Ø§Ù„ÙˆÙ‚Øª', color: '#000' },
                                ticks: { 
                                    color: '#000',
                                    autoSkip: true, 
                                    maxRotation: 0,
                                    minRotation: 0
                                }, 
                                grid: { color: 'rgba(0, 0, 0, 0.2)' }
                            },
                            y: {
                                title: { display: true, text: 'Ø¹Ø¯Ø¯ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª', color: '#000' },
                                ticks: { color: '#000' },
                                grid: { color: 'rgba(0, 0, 0, 0.2)' },
                                beginAtZero: true, 
                                min: 0,
                                ticks: {
                                    stepSize: 1,
                                    color: '#000'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#000'
                                }
                            },
                            tooltip: { 
                                enabled: true,
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return tooltipItems[0].label; 
                                    }
                                }
                            },
                            interfaceChangeAnnotator: {
                                changeData: [] 
                            }
                        }
                    },
                    plugins: [interfaceChangeAnnotator] 
                });
            } else {
                console.error("Canvas element not found");
            }
            const container = document.querySelector('.container');
            
            const newControlsHTML = `
                <div id="displayDurationControls" style="text-align: center; margin-top: 20px;">
                    <label>â±ï¸ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯Ø© Ø§Ù„Ø¹Ø±Ø¶ ÙÙŠ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ :</label>
                    <div id="chartDurationFields" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px; background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 10px;">
                        <div class="duration-input-group"><input type="number" id="chart_hours" placeholder="00" min="0" value="0" style="width: 50px;"> Ø³Ø§Ø¹Ø©</div>
                        <div class="duration-input-group"><input type="number" id="chart_minutes" placeholder="00" min="0" value="5" style="width: 50px;"> Ø¯Ù‚ÙŠÙ‚Ø©</div>
                        <div class="duration-input-group"><input type="number" id="chart_seconds" placeholder="00" min="0" value="0" style="width: 50px;"> Ø«Ø§Ù†ÙŠØ©</div>
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø© Ø­Ø§Ù„ÙŠØ§Ù‹: <span id="currentDurationLabel">5 Ø¯Ù‚Ø§Ø¦Ù‚</span></p>
                    
                    <button id="applyChartDurationBtn" class="action-btn" style="background-color: #007bff; margin-top: 10px;">ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ø±Ø¶</button>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', newControlsHTML);
            
            const applyBtn = document.getElementById('applyChartDurationBtn');
            const durationLabel = document.getElementById('currentDurationLabel');
            
            function applyNewChartDuration() {
                const hours = parseInt(document.getElementById('chart_hours').value) || 0;
                const minutes = parseInt(document.getElementById('chart_minutes').value) || 0;
                const seconds = parseInt(document.getElementById('chart_seconds').value) || 0;
                const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
                if (totalSeconds <= 0) {
                    alert("âš ï¸ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ø¯Ø© Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±.");
                    return;
                }
                maxDisplaySeconds = totalSeconds;
                durationLabel.textContent = getDurationString(totalSeconds);
                clearInterval(dataFetcherInterval);
                dataFetcherInterval = setInterval(refreshData, FETCH_TIME);
                refreshData();
            }
            applyBtn.onclick = applyNewChartDuration;
            
            dataFetcherInterval = setInterval(refreshData, FETCH_TIME); 
            document.getElementById('currentDurationLabel').textContent = getDurationString(maxDisplaySeconds);
            refreshData();
        });
    </script>
    <script> const mode = 'network'; </script>
</body>
</html>